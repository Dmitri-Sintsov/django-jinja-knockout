.. _client_routes: https://github.com/Dmitri-Sintsov/django-jinja-knockout/search?l=Python&q=client_routes
.. _create_template_context(): https://github.com/Dmitri-Sintsov/django-jinja-knockout/search?l=Python&q=create_template_context
.. _flatatt(): https://github.com/django/django/search?l=Python&q=flatatt
.. _format_html(): https://github.com/django/django/search?l=Python&q=format_html
.. _get_client_conf(): https://github.com/Dmitri-Sintsov/django-jinja-knockout/search?l=HTML&q=get_client_conf
.. _get_client_data(): https://github.com/Dmitri-Sintsov/django-jinja-knockout/search?l=HTML&q=get_client_data
.. _get_client_urls(): https://github.com/Dmitri-Sintsov/django-jinja-knockout/search?l=Python&q=get_client_urls
.. _get_verbose_name(): https://github.com/Dmitri-Sintsov/django-jinja-knockout/search?l=Python&q=get_verbose_name
.. _get_view_title(): https://github.com/Dmitri-Sintsov/django-jinja-knockout/search?l=HTML&q=get_view_title
.. _get_custom_scripts: https://github.com/Dmitri-Sintsov/django-jinja-knockout/search?l=HTML&q=get_custom_scripts
.. _TemplateContext: https://github.com/Dmitri-Sintsov/django-jinja-knockout/search?l=Python&q=TemplateContext
.. _template_context_decorator: https://github.com/Dmitri-Sintsov/djk-sample/search?l=Python&q=template_context_decorator
.. _tpl: https://github.com/Dmitri-Sintsov/django-jinja-knockout/blob/master/django_jinja_knockout/tpl.py
.. _utils.sdv: https://github.com/Dmitri-Sintsov/django-jinja-knockout/blob/master/django_jinja_knockout/utils/sdv.py

=====================
context_processors.py
=====================

Context processor injects the `tpl`_ / `utils.sdv`_ modules to to Jinja2 template context, allowing to write more
powerful templates. Any function / class from these modules are immediately available in Jinja2 templates. Additionally
some useful functions / classes are loaded (see `Meta and formatting`_).

* `tpl`_ module implements functions / classes for advanced text / html formatting; see :doc:`tpl` for detailed
  information.
* `utils.sdv`_ module implements low-level support functions / classes;

Functions to manipulate css classes in Jinja2 templates
-------------------------------------------------------

* ``tpl.add_css_classes()`` - similar to jQuery ``$.addClass()`` function;
* ``tpl.has_css_classes()`` - similar to jQuery ``$.hasClass()`` function;
* ``tpl.remove_css_classes()`` - similar to jQuery ``$.removeClass()`` function;

Next are the methods that alter 'class' key value of the supplied HTML attrs dict, which is then passed to Django
``flatatt()`` call / ``tpl.json_flatatt()`` call:

* ``tpl.add_css_classes_to_dict()``
* ``tpl.has_css_classes_in_dict()``
* ``tpl.prepend_css_classes_to_dict()``
* ``tpl.remove_css_classes_from_dict()``

.. _TemplateContext (djk context):

TemplateContext (djk context)
-----------------------------

Since version 0.9.0, `TemplateContext`_ class is used to generate context variables required to run client-side of the
framework itself.

The singleton instance of `TemplateContext`_ is stored into current ``request`` ``.template_context`` attribute, which
is instantiated / updated via `create_template_context()`_ function call from Django view. When the response is
generated and template context processor is called, the instance of `TemplateContext`_ is stored into ``djk`` context
variable. The following methods are used to get view data in templates:

* `get_view_title()`_ - see :ref:`views_view_title`
* `get_client_conf()`_ - see `Injection of Django url routes into loaded page`_
* `get_client_data()`_ - see `Injection of server-side data into loaded page`_
* `get_custom_scripts`_ - see `Injection of custom script urls into loaded page`_

.. highlight:: python

Injection of Django url routes into loaded page
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

* `get_client_conf()`_ method returns the dict which is passed to client-side as ``App.conf`` Javascript object with the
  following keys:

 * ``'jsErrorsAlert'`` - boolean value, whether Javascript errors should produce modal alert;
 * ``'jsErrorsLogging'`` - boolean value, whether Javascript errors should be reported to admin email;

   * See also :doc:`installation` how to setup Javascript error logging.

 * ``'csrfToken'`` - current CSRF token to be used with AJAX POST from Javascript;
 * ``'languageCode'`` - current Django language code;
 * ``'staticPath'`` - root static url path to be used with AJAX requests from Javascript;
 * ``'userId'`` - current user id, 0 for anonymous; used to detect authorized users and with AJAX requests;
 * ``'url'`` - the dict of Django {``url name``: ``sprintf pattern``}, generated by `get_client_urls()`_ method from the
   set of Django url names (`client_routes`_) which are later converted to Javascript object to be used with AJAX
   requests. It allows not to have hard-coded app urls in Javascript code. Url names with kwargs are supported since
   v0.2.0. Namespaced urls are supported since v0.9.0.

To add client-side accessible url in function-based view::

    from django_jinja_knockout.views import create_template_context

    def my_view(request):
        create_template_context(request).add_client_routes({
            'club_detail',
            'member_grid',
        })

To add client-side accessible url in CBV::

    from django_jinja_knockout.views import create_template_context

    def get_context_data(self, **kwargs):
        create_template_context(self.request).add_client_routes({
            'club_detail',
            'member_grid',
        })

Single url can be added as::

    create_template_context(request).add_client_routes('club_detail')

template_context_decorator()
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

`template_context_decorator`_ allows to quickly provide ``view_title`` / ``client_data`` / ``client_routes`` /
``custom_scripts`` for function-based Django views::

    from django_jinja_knockout.views import template_context_decorator

    @template_context_decorator(
        view_title='Decorated main page title',
        client_routes={'club_detail', 'club_edit'}
    )
    def main_page(request, **kwargs):
        return render(request, 'main.htm')

Injection of server-side data into loaded page
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.. highlight:: html

* `get_client_data()`_ method returns the dict, injected as JSON to HTML page, which is accessible at client-side as
  ``App.clientData`` Javascript object.

Sample template ::

    <script language="JavaScript">
        App.conf = {{ djk.get_client_conf()|to_json(True) }};
        App.clientData = {{ djk.get_client_data()|to_json(True) }};
    </script>

.. highlight:: Python

To pass data from server-side Python to client-side Javascript, one has to access `TemplateContext`_ singleton instance::

    from django_jinja_knockout.views import create_template_context

    create_template_context(request).add_client_data({
        'club_id': self.object_id
    })

It may also include optional JSON client-side viewmodels, stored in ``onloadViewModels`` key, which are executed when
html page is loaded (see :doc:`viewmodels` for more info)::

    create_template_context(self.request).add_client_data({
        'onloadViewModels': {
          'view': 'alert',
          'message': 'Hello, world!',
        }
    })

Injection of custom script urls into loaded page
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

To inject custom script to the bottom of loaded page, use the following call in Django view::

    from django_jinja_knockout.views import create_template_context

    create_template_context(request).add_custom_scripts(
        'djk/js/formsets.js',
        'djk/js/grid.js',
    )

.. highlight:: jinja

To add custom script from within Django template, use `TemplateContext`_ instance stored into ``djk`` context variable::

    {% do djk.add_custom_scripts(
        'djk/js/formsets.js',
        'djk/js/grid.js',
    ) -%}

The order of added scripts is respected, however multiple inclusion of the same script will be omitted to prevent
client-side glitches. There is also an additional check against inclusion of duplicate scripts at client-side via
``App.assertUniqueScripts()`` function call.

Meta and formatting
-------------------

* `get_verbose_name()`_ allows to get verbose_name of Django model field, including related (foreign) and reverse
  related fields.
* Django functions used to format html content: `flatatt()`_ / `format_html()`_.
* Possibility to raise exceptions in Jinja2 templates::

  {{ raise('Error message') }}

Advanced url resolution, both forward and reverse
-------------------------------------------------
.. highlight:: python

* ``tpl.resolve_cbv()`` takes url_name and kwargs and returns a function view or a class-based view for these arguments,
  when available::

    tpl.resolve_cbv(url_name, view_kwargs)

* ``tpl.reverseq()`` allows to build reverse urls with optional query string specified as Python dict::

    tpl.reverseq('my_url_name', kwargs={'project_id': project.pk}, query={'type': 'approved'})

See :doc:`tpl` for more info.

Miscelaneous
------------
* ``sdv.dbg()`` for optional template variable dump (debug).
* Context processor is inheritable which allows greater flexibility to implement your own custom features by
  overloading methods.
