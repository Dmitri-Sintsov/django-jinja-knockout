.. _client_routes: https://github.com/Dmitri-Sintsov/django-jinja-knockout/search?l=Python&q=client_routes
.. _create_template_context(): https://github.com/Dmitri-Sintsov/django-jinja-knockout/search?l=Python&q=create_template_context
.. _get_client_urls(): https://github.com/Dmitri-Sintsov/django-jinja-knockout/search?l=Python&q=get_client_urls
.. _TemplateContext: https://github.com/Dmitri-Sintsov/django-jinja-knockout/search?l=Python&q=TemplateContext
.. _tpl: https://github.com/Dmitri-Sintsov/django-jinja-knockout/blob/master/django_jinja_knockout/tpl.py
.. _utils.sdv: https://github.com/Dmitri-Sintsov/django-jinja-knockout/blob/master/django_jinja_knockout/utils/sdv.py

=====================
context_processors.py
=====================

Context processor injects the `tpl`_ / `utils.sdv`_ modules to to Jinja2 template context, allowing to write more
powerful templates. Any function / class from these modules are immediately available in Jinja2 templates. Additionally
some useful functions / classes are loaded (see `Meta and formatting`_).

* `tpl`_ module implements functions / classes for advanced text / html formatting; see :doc:`tpl` for detailed
  information.
* `utils.sdv`_ module implements low-level support functions / classes;

Functions to manipulate css classes in Jinja2 templates
-------------------------------------------------------

* ``tpl.add_css_classes()`` - similar to jQuery ``$.addClass()`` function;
* ``tpl.has_css_classes()`` - similar to jQuery ``$.hasClass()`` function;
* ``tpl.remove_css_classes()`` - similar to jQuery ``$.removeClass()`` function;

Next are the methods that alter 'class' key value of the supplied HTML attrs dict, which is then passed to Django
``flatatt()`` call / ``tpl.json_flatatt()`` call:

* ``tpl.add_css_classes_to_dict()``
* ``tpl.has_css_classes_in_dict()``
* ``tpl.prepend_css_classes_to_dict()``
* ``tpl.remove_css_classes_from_dict()``

.. _TemplateContext (djk context):

TemplateContext (djk context)
-----------------------------

Since version 0.9.0, `TemplateContext`_ class is used to generate context variables required to run client-side of the
framework itself. These variables are placed into ``djk`` context dict, including the following keys:

* ``view_title`` - see :ref:`views_view_title`
* ``client_conf`` - see `Injection of Django url routes into loaded page`_
* ``client_data`` - see `Injection of server-side data into loaded page`_
* ``custom_scripts`` - see `Injection of custom script urls into loaded page`_

The singleton instance of `TemplateContext`_ is stored into current ``request``.``template_context`` attribute, which
is instantiated / updated by `create_template_context()`_ function.

.. highlight:: python

Injection of Django url routes into loaded page
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

* ``client_conf`` dict is passed to be accessed at client-side via ``App.conf`` Javascript object with the following
  keys:

 * ``'jsErrorsAlert'`` - boolean value, whether Javascript errors should produce Bootstrap alert;
 * ``'jsErrorsLogging'`` - boolean value, whether Javascript errors should be reported to admin email;

   * See also :doc:`installation` how to setup Javascript error logging.

 * ``'csrfToken'`` - current CSRF token to be used with AJAX POST from Javascript;
 * ``'languageCode'`` - current Django language code;
 * ``'staticPath'`` - root static url path to be used with AJAX requests from Javascript;
 * ``'userId'`` - current user id, 0 for anonymous; used both in Jinja2 templates to detect authorized users and from
   Javascript mostly with AJAX requests;
 * ``'url'`` - the dict of Django {``url name``: ``sprintf pattern``}, generated by `get_client_urls()`_ method from the
   set of Django url names (`client_routes`_) which are later converted to Javascript object to be used with AJAX
   requests from Javascript. It allows not to have hard-coded app urls in Javascript code. Url names with kwargs are
   supported since v0.2.0. Namespaced urls are supported since v0.9.0.


To add client-side accessible url in function-based view::

    from django_jinja_knockout.views import create_template_context

    def my_view(request):
        create_template_context(request).add_client_routes({
            'club_detail',
            'member_grid',
        })

To add client-side accessible url in CBV::

    from django_jinja_knockout.views import create_template_context

    def get_context_data(self, **kwargs):
        create_template_context(self.request).add_client_routes({
            'club_detail',
            'member_grid',
        })

Single url can be added as::

    create_template_context(request).add_client_routes('club_detail')

Injection of server-side data into loaded page
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.. highlight:: html

* ``client_data`` dict to be injected as JSON to HTML page, which is accessible then at client-side as
  ``App.clientData`` Javascript object::

    <script language="JavaScript">
        App.conf = {{ djk.client_conf|escapejs(True) }};
        App.clientData = {{ djk.client_data|escapejs(True) }};
    </script>

It may include optional JSON client-side viewmodels, stored in ``onloadViewModels`` key, which are executed when html
page is loaded, see :doc:`viewmodels` for more info.

Injection of custom script urls into loaded page
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Todo:

Meta and formatting
-------------------
.. highlight:: python

* ``get_verbose_name()`` allows to get verbose_name of Django model field, including related (foreign) and reverse
  related fields.
* Django functions to format html content: ``flatatt()`` / ``format_html()`` / ``force_text()``.
* Possibility to raise exceptions in Jinja2 templates via ``{{ raise('Error message') }}``

Advanced url resolution, both forward and reverse
-------------------------------------------------

* ``tpl.resolve_cbv()`` takes url_name and kwargs and returns a function view or a class-based view for these arguments,
  when available::

    tpl.resolve_cbv(url_name, view_kwargs)

* ``tpl.reverseq()`` allows to build reverse urls with optional query string specified as Python dict::

    tpl.reverseq('my_url_name', kwargs={'project_id': project.pk}, query={'type': 'approved'})

Miscelaneous
------------
* ``sdv.dbg()`` for optional template variable dump (debug).
* Context processor is inheritable which allows greater flexibility to implement your own custom features by
  overloading methods.
